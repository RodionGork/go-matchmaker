Попробуем создать достаточно гибкую реализацию по поводу того, что задание не содержит конкретики
в отношении критериев мэтчинга а наоборот даже можно сказать несколько противоречиво:

    Матчмейкер должен формировать группы игроков, стараясь удовлетворить следующим критериям:
    - разница в задержке (latency) игроков должна быть минимальной
    - разница в уровне навыка (skill) игроков должна быть минимальной
    - время ожидания игрока в очереди должно быть минимальным

Например, невозможно идеально удовлетворить одновременно первому и третьему критерию вместе -
допустим к нам пришли с небольшой разницей во времени два игрока с некоторой разницей скиллов -
мы не можем знать, придёт ли в следующую секунду кто-то более близкий по скиллу к первому из них
или надо мэтчить его сейчас со вторым и не думать о будущем.

Кроме того представляется что на практике детальные критерии и алгоритм мэтчинга вырабатываются постепенно
в итеративном процессе - сделали, попробовали, улучшили, попробовали и так далее. Помимо того здесь
могут быть вовлечены аналитики (дата-сайентисты, математики) помимо непосредственных разработчиков сервиса.

В связи с этим поступим так - сервис на `Go` принимает запросы от пользователей и формирует пул (очередь)
ждущих - а мэтчинг выполняется скриптом на `Lua`, которому сервис передаёт текущее состояние пула при вызове -
и обрабатывает результаты мэтчинга.

_Почему именно `Lua`? Это некритично конечно, следует исходить из коньюнктуры - мы взяли реализацию `go-lua`
разработанную и используемую в `Shopify`, так что это industrial-mature решение. Кроме этого синтаксис `Lua`
похож на упрощённый Python и возможно один из наиболее "человечных" среди скриптовых языков. В качестве альтернативы
в сервисах на `Go` довольно популярен например `tengo`, но тестирование его в отрыве от `Go` будет осложнено._

**Преимущества которые даёт нам этот подход:**

- алгоритм мэтчинга могут разрабатывать люди не знакомые с Go (освоение Lua на порядок проще)
- тестировать алгоритм можно вне сервиса, простым скриптом "драйвером" (см. tests/matcher_test.lua)
- алгоритм можно менять без пересборки сервиса, можно использовать разные алгоритмы на разных инстансах или даже
    добавить возможность смены его "на лету" (например ночью и днём мы хотим разные алгоритмы в связи с разным объёмом пользователей)

### Технические Детали

Файл `main.go` инициализирует объект-мэтчер и запускает http-сервер. Код сервера в `network.go`, там ничего особенного,
запросы принимаются в JSON формата

    {"name":"Clown_Gay", "skill":13.4, "latency":3.5}

Запросы попадают в пул (в коде он называется очередь, `queue`) через канад `purgatory` - таким образом решается вопрос
синхронизации in-memory хранилища: доступ к `queue` имеет только сам matcher, вызываемый периодически - он же и выгребает
`purgatory` перед очередным сеансом мэтчинга.

_В случае хранения пула в базе данных такая синхронизация не нужна (она решается силами самой БД при нужной степени
изоляции транзакций) - однако в данной реализации хранение на БД не используется (то ли я не заметил изначально это пожелание,
то ли его дописали в последней версии задания - в любом случае это непринципиально в контексте данной реализации и
потому просто неинтересно - впрочем и на практике наверное не для любой игры персистентное хранилище хорошо)._

Мэтчер запускает сконфигурированный lua файл - по умолчанию используется заэмбеженый `simple_matcher.lua` который
просто для демонстрации формирует группы тупо по порядку прибытия. Переменная среды `MATCHER_FILE` позволяет выбрать
другой файл, например `euclid_matcher.lua`.

Этот мэтчер использует довольно общую концепцию - мы можем себе представить пространство N критериев как N-мерное декартово
пространство и выбирать близко-расположенные точки. Здесь возникают впрочем два нюанса:

- оси нужно масштабировать (то есть веса критериев могут входить с разными коэффициентами и вообще необязательно линейно)
- порядок выбора групп важен - если сначала "вымести" группы из центральных точек, то оставшиеся будут довольно
  разрежены и выдадут плохие совпадения

Файл `euclid_matcher.lua` для простоты использует только skill и latency. Можно при желании попросту добавить time в формулу -
в демо-видео это будет показано.
